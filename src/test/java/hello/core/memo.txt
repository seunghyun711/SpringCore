<스프링 빈 조회 - 상속관계>
부모 타입을 조회하면 자식 타입도 다 같이 조회한다.
모든 자바 객체의 최고 부모인 Object 타입으로 조회하면 모든 스프링 빈을 조회한다.

<BeanDefinition>
스프링은 BeanDefinition으로 스프링의 설정 메타 정보를 추상화한다.
스프링 빈 생성은 2가지 방법이 있다.
1. 직접 스프링 빈으로 등록
2. 팩토리 빈으로 등록 -> 일반적으로 사용

<스프링 없는 순수 DI 컨테이너>
지금까지 만든 AppConfig는 순수 DI 컨테이너로 요청을 할 때마다 객체를 새로 생성했다.
따라서 요청이 100개가 들어오면 그 요청에 따른 객체를 100번을 호추하는 것이다. 메모리 낭비가 심하다.
해결방안으로 객체가 1개만 생성되고 공유하도록 설계, 즉 싱글톤 패턴을 적용해야 한다.

<싱글톤 패턴>
싱글톤을 적용하면 요청이 올 때마다 객체를 생성하는 것이 아니라 이미 만들어진 객체를 공유해서 효율적으로 사용할 수 있다.
문제점
- 싱글톤 구현 코드 필요
- 의존관계상 클라이언트가 구체 클래스에 의존
- 클라이언트가 구체 클래스에 의존해 OCP원칙을 위반 할 가능성이 생긴다.
- 테스트가 어렵다.
- 내부 속성 변경하거나 초기화가 어렵다.
- private 생성자로 자식 클래스를 만들기 어렵다.
- 유연성이 떨어진다.
==> 싱글톤 패턴의 문제점은 싱글톤 컨테이너로 해결할 수 있다.

<싱글톤 컨테이너>
스프링 컨테이너는 싱글톤으로 지정하지 않아도 객체 인스턴스를 싱글톤으로 관리한다.
스프링 컨테이너는 싱글톤 컨테이너의 역할을 한다.
스프링 컨테이너를 통해 요청이 올 떄마다 객체를 생성하지 않고, 이미 만들어진 객체를 공유하여 효율적으로 재사용할 수 있다.

<싱글톤 주의점>
하나의 객체 인스턴스를 공유해서 사용하는 것이기 떄문에 여러 클라이언트가 공유 객체를 사용할 때마다 상태를 변경을 하면 안된다.
즉, 무상태(stateless)로 설계해야 한다.
- 특정 클라이언트에 의존적인 필드가 있으면 안된다.
- 특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안된다.
- 가급적 읽기만 가능해야 한다.
- 필드 대신 자바에서 공유되지 않는 지역변수, threadLocal, 파라미터 등을 사용한다.

<Configuration과 싱글톤>
AppConfig에서 memberService빈에서 memberRepository를 호출하고, orderService빈에서 memberRepository를 호출한다. 이렇게 각각 다른 2개의
memberRepository가 호출되는 것 처럼 보이고, 싱글톤이 깨지는 것 같다. 하지만 확인해보면 이 2개의 memberRepository는 모두 같은 인스턴스이다.

